{"ast":null,"code":"import { transformToNestObject as e } from \"react-hook-form\";\n\nfunction r() {\n  return (r = Object.assign || function (e) {\n    for (var r = 1; r < arguments.length; r++) {\n      var t = arguments[r];\n\n      for (var n in t) {\n        Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n      }\n    }\n\n    return e;\n  }).apply(this, arguments);\n}\n\nvar t = function t(_t, n) {\n  return void 0 === n && (n = {\n    abortEarly: !1\n  }), function (o, a, s) {\n    void 0 === s && (s = !1);\n\n    try {\n      return Promise.resolve(function (e, s) {\n        try {\n          var c = (n.context && \"development\" === process.env.NODE_ENV && console.warn(\"You should not used the yup options context. Please, use the 'useForm' context object instead\"), Promise.resolve(_t.validate(o, r({}, n, {\n            context: a\n          }))).then(function (e) {\n            return {\n              values: e,\n              errors: {}\n            };\n          }));\n        } catch (e) {\n          return s(e);\n        }\n\n        return c && c.then ? c.then(void 0, s) : c;\n      }(0, function (t) {\n        if (!t.inner) throw t;\n\n        var n = function (e, t) {\n          var n;\n          return Array.isArray(e.inner) && e.inner.length ? e.inner.reduce(function (e, n) {\n            var o,\n                a,\n                s = n.path,\n                c = n.message,\n                u = n.type,\n                i = e[s] && e[s].types || {},\n                p = s || u;\n            return r({}, e, p ? ((a = {})[p] = r({}, e[p] || {\n              message: c,\n              type: u\n            }, t ? {\n              types: r({}, i, (o = {}, o[u] = i[u] ? [].concat([].concat(i[u]), [c]) : c, o))\n            } : {}), a) : {});\n          }, {}) : ((n = {})[e.path] = {\n            message: e.message,\n            type: e.type\n          }, n);\n        }(t, s);\n\n        return {\n          values: {},\n          errors: e(n)\n        };\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n};\n\nexport { t as yupResolver };","map":{"version":3,"mappings":";;;;;;;;;;;;;;AAWA;;AAAA,IAiDaA,IAAc,WACzBC,EADyB,EAEzBC,CAFyB,EAEzBA;EAAAA,4BAAgD;IAC9CC,aAAY;EADkC,CAAhDD,GACc,UAGdE,CAHc,EAIdC,CAJc,EAKdC,CALc,EAKdA;IAAAA,sBAA2B,CAA3BA;;IAA2B;MAAA;QAAA;UAAA,SAGrBJ,EAAQG,OAARH,IAA4C,kBAAzBK,QAAQC,GAARD,CAAYE,QAA/BP,IAEFQ,QAAQC,IAARD,CACE,+FADFA,CAFER,EAGAU,gBAIYX,GAAOY,QAAPZ,CAAgBG,CAAhBH,EAAgBG,MACzBF,CADyBE,EACzBF;YACHG;UADGH,CADyBE,CAAhBH,CAJZ,EAMAI,IANA,CAMAA;YAHJ,OAAO;cACLD,SADK;cAKLU,QAAQ;YALH,CAAP;UAKU,CARN,CANqB;QAcf,CAde,CAcf;UAAA;QAAA;;QAAA;MAAA,CAde,CAcf,CAde,EAcf,UAEHC,CAFG,EAEHA;QACP,KAAKA,EAAEC,KAAP,EACE,MAAMD,CAAN;;QAGF,IAAME,IA9Ee,UACvBC,CADuB,EAEvBZ,CAFuB,EAEvBA;UAAAA;UAEA,OAAOa,MAAMC,OAAND,CAAcD,EAAMF,KAApBG,KAA8BD,EAAMF,KAANE,CAAYG,MAA1CF,GACHD,EAAMF,KAANE,CAAYI,MAAZJ,CACE,UAACK,CAAD,EAACA,CAAD,EAACA;YAAAA;YAAAA;YAAAA,IAAiCC,UAAjCD;YAAAA,IAAuCE,aAAvCF;YAAAA,IAAgDG,UAAhDH;YAAAA,IAEOI,IAAiBJ,EAASC,CAATD,KAAkBA,EAASC,CAATD,EAAeK,KAAjCL,IAA2C,EAFnEA;YAAAA,IAGOM,IAAML,KAAQE,CAHrBH;YAKC,aACKA,CADL,EAEMM,cAEGA,CAFHA,IAEGA,MACKN,EAASM,CAATN,KAAiB;cACnBE,UADmB;cAEnBC;YAFmB,CADtBG,EAKKvB,IACA;cACEsB,aACKD,CADLC,GACKD,UAEFD,CAFEC,IAEKA,EAAcD,CAAdC,IAAcD,UAEd,GAAGI,MAAH,CAAUH,EAAcD,CAAdC,CAAV,CAFcD,EAEUA,CAAQD,CAARC,CAFVA,CAAdC,GAGJF,CALDE,EAKCF,CANNG;YADF,CADAtB,GAWA,EAhBLuB,CAFHA,EAkBQE,CAlBRF,IAqBA,EAvBN;UAuBM,CA7BVX,EAgCE,EAhCFA,CADGC,IAiCD,SAICD,EAAMM,IAJP,IAIc;YAAEC,SAASP,EAAMO,OAAjB;YAA0BC,MAAMR,EAAMQ;UAAtC,CAJd,EAIoDA,CArCnDP,CAAP;QA0EuBa,CA9EA,CA8EiBjB,CA9EjB,EA8EoBT,CA9EpB,CA8ErB;;QACA,OAAO;UACLF,QAAQ,EADH;UAELU,QAAQmB,EAAsBhB,CAAtBgB;QAFH,CAAP;MAEgChB,CAxBP;IARF,CAQE,CARF;MAAA;IAAA;EAAA,CAEzBf;AAFyB,CAjD3B;;AAiD2B","names":["yupResolver","schema","options","abortEarly","values","context","validateAllFieldCriteria","process","env","NODE_ENV","console","warn","Promise","validate","errors","e","inner","parsedErrors","error","Array","isArray","length","reduce","previous","path","message","type","previousTypes","types","key","concat","a","parseErrorSchema","transformToNestObject"],"sources":["../src/yup.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport { Resolver, transformToNestObject, FieldValues } from 'react-hook-form';\nimport Yup from 'yup';\nimport Lazy from 'yup/lib/Lazy';\n\n/**\n * From 0.32.0, Yup add TypeScript support and `path` typing is optional that's why we have `@ts-expect-error`\n * FYI: `path`: a string, indicating where there error was thrown. `path` is empty at the root level.\n * react-hook-form's values are object so path is defined\n * https://github.com/jquense/yup#validationerrorerrors-string--arraystring-value-any-path-string\n */\nconst parseErrorSchema = (\n  error: Yup.ValidationError,\n  validateAllFieldCriteria: boolean,\n) => {\n  return Array.isArray(error.inner) && error.inner.length\n    ? error.inner.reduce(\n        (previous: Record<string, any>, { path, message, type }) => {\n          // @ts-expect-error\n          const previousTypes = (previous[path] && previous[path].types) || {};\n          const key = path || type;\n\n          return {\n            ...previous,\n            ...(key\n              ? {\n                  [key]: {\n                    ...(previous[key] || {\n                      message,\n                      type,\n                    }),\n                    ...(validateAllFieldCriteria\n                      ? {\n                          types: {\n                            ...previousTypes,\n                            // @ts-expect-error\n                            [type]: previousTypes[type]\n                              ? // @ts-expect-error\n                                [...[].concat(previousTypes[type]), message]\n                              : message,\n                          },\n                        }\n                      : {}),\n                  },\n                }\n              : {}),\n          };\n        },\n        {},\n      )\n    : {\n        // @ts-expect-error\n        [error.path]: { message: error.message, type: error.type },\n      };\n};\n\ntype ValidateOptions<T extends Yup.AnyObjectSchema> = Parameters<\n  T['validate']\n>[1];\n\nexport const yupResolver = <TFieldValues extends FieldValues>(\n  schema: Yup.AnyObjectSchema | Lazy<any, any>,\n  options: ValidateOptions<Yup.AnyObjectSchema> = {\n    abortEarly: false,\n  },\n): Resolver<TFieldValues> => async (\n  values,\n  context,\n  validateAllFieldCriteria = false,\n) => {\n  try {\n    if (options.context && process.env.NODE_ENV === 'development') {\n      // eslint-disable-next-line no-console\n      console.warn(\n        \"You should not used the yup options context. Please, use the 'useForm' context object instead\",\n      );\n    }\n    return {\n      values: await schema.validate(values, {\n        ...options,\n        context,\n      }),\n      errors: {},\n    };\n  } catch (e: any) {\n    if (!e.inner) {\n      throw e;\n    }\n\n    const parsedErrors = parseErrorSchema(e, validateAllFieldCriteria);\n    return {\n      values: {},\n      errors: transformToNestObject(parsedErrors),\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"module"}